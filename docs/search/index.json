[{"content":"GÃ¶mÃ¼lÃ¼ Sistemlerde HaberleÅŸme Merhaba, bu yazÄ±mÄ±nda sizlerle gÃ¶mÃ¼lÃ¼ sistemlerde haberleÅŸme nasÄ±l yapÄ±lÄ±r ondan bahsedeceÄŸim.\nÃ–ncellikle yazÄ±ya geÃ§meden Ã¶nce sizlere geÃ§en sene en Ã§ok sorun yaÅŸadÄ±ÄŸÄ±m bu haberleÅŸme konusunun neden Ã¶nemli olduÄŸundan bahsedeceÄŸim. Bir inÅŸaatta nasÄ±l temel olmadan diÄŸer katlara geÃ§ilemeyeceÄŸi gibi model uyduda da iletiÅŸim olmadan diÄŸer iÅŸlemleri gerÃ§ekleÅŸtiremezsiniz. EÄŸer haberleÅŸme dÃ¼zgÃ¼n kurulmuyorsa diÄŸer yaptÄ±ÄŸÄ±nÄ±z tÃ¼m iÅŸlemler hiÃ§bir iÅŸe yaramÄ±yacaktÄ±r. HaberleÅŸmede yaÅŸayacaÄŸÄ±nÄ±z en ufak aksaklÄ±k haliyle arayÃ¼zÃ¼nÃ¼zde sorunlara da yol aÃ§abilir. BunlarÄ±n tedbirlerini almanÄ±z gerekmektedir. Ben sizlere haberleÅŸme konusunda yaÅŸadÄ±ÄŸÄ±m yazÄ±lÄ±msal problemleri anlatacaÄŸÄ±m. Ancak sizlerinde bu hatalarÄ± gÃ¶rÃ¼p nasÄ±l Ã§Ã¶zÃ¼m bulunduÄŸu gÃ¶rmeniz iÃ§in Ã¶ncelikle sorunu belirtip daha sonra sorunun Ã§Ã¶zÃ¼mÃ¼ gÃ¶stereceÄŸim. Bunlardan bazÄ±larÄ± kendim yapmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±m yÃ¶ntemler olacaktÄ±r ve muhtemelen sizlerde ilk olarak bu yÃ¶ntemlerden birini kulanacaksÄ±nÄ±z. Evet hazÄ±rsak baÅŸlÄ±yoruzâ€¦\n\r\nÄ°Ã§indekiler  ArayÃ¼z HaberleÅŸme  XML JSON NanoPb    ArayÃ¼z Model Uydu iÃ§in arayÃ¼z tasarlarken belli baÅŸlÄ± adÄ±mlarÄ± izlemeniz gerekiyor. Bu adÄ±mlarÄ± ben kÄ±saca ÅŸÃ¶yle adÄ±mlÄ±yorum;\n Ä°lk olarak arayÃ¼zde istenilen isterlerin belirlenmesi. Bu isterler Ã¼zerinden arayÃ¼zÃ¼ tasarlamak.(BakÄ±n ilk Ã¶nce arayÃ¼zÃ¼ tasarlayÄ±n hele ki tek kiÅŸi tasarlÄ±yorsanÄ±z.) Daha sonra arayÃ¼z az Ã§ok hazÄ±r olduktan sonra artÄ±k backend(lojik katman) kÄ±smÄ±na geÃ§ebilirsiniz. Backend kÄ±smÄ±nda ise uÃ§uÅŸ yazÄ±lÄ±mÄ±nÄ±z bÃ¼yÃ¼k ihtimalle hala yazÄ±lmamÄ±ÅŸtÄ±r. Peki neye gÃ¶re yazacam diyeceksinizdir. Burada ise tamamen sanki telemetri verisi iletilmiÅŸ ve siz bu veriyi okumuÅŸsunuz gibi davranÄ±n. ArdÄ±ndan okunan verileri artÄ±k kullanÄ±lacak yerlere yerleÅŸtirin. Ancak veri transferi hakkÄ±nda hiÃ§bir ÅŸey bilmiyorsanÄ±z basit olarak bir kaÃ§ deneme yapabilirsiniz. Tamam artÄ±k ÅŸimdi veri transfer etmeye ve bu transfer edilen verinin okunmasÄ± adÄ±mÄ±na geÃ§tik.  Bu adÄ±mlar az Ã§ok her arayÃ¼z tasarÄ±mÄ± iÃ§in geÃ§erli olacaktÄ±r.Hadi biraz detaya girelim ve bir arayÃ¼z tasarlayalÄ±m ve bu adÄ±mlarÄ± Ã¼zerinde uygulayalÄ±m.\n\r\nÅimdi yukarÄ±daki resimde arayÃ¼zÃ¼ basit manada oluÅŸturduk ve gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi Ã§ok fazla eksik var ve bu eksikleri tamamen isterler Ã¼zerinden giderek eklememiz gerekiyor. Ben 2020 yÄ±lÄ± TÃ¼rksat Model Uydu iÃ§in istenen isterler Ã¼zerinden gideceÄŸim. Arka plan kamerayÄ± saÄŸ alt kÃ¶ÅŸedeki dikdÃ¶rtgen ise haritayÄ± teslim etmektedir. Gps ve oriantaion(yaw,pitch,roll), takÄ±m numarasÄ±, batary, tarih ve saat gibi bir kaÃ§ ÅŸey belirtilmiÅŸ fakat eksikleri daha sonra ekleyeceÄŸiz. GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi arayÃ¼z oluÅŸturuldu ama eksikler var. Zaten her ÅŸeyi bir anda tasarlayamayacaÄŸÄ±mÄ±z farkÄ±ndayÄ±m ben de ÅŸuanlÄ±k bÃ¶yle bÄ±rakÄ±p artÄ±k backend kodlarÄ±na geÃ§eceÄŸim. Daha sonra eksik olan kÄ±sÄ±mlarÄ± dÃ¼zenleyeceÄŸiz. Burada ise Ã§ok Ã¶nemli kÄ±sÄ±m UI ile logic kÄ±smÄ± bir birinden ayÄ±rmanÄ±z bu size tasarÄ±mda oldukÃ§a esneklik saÄŸlayacakÄ±r. BÃ¶yle bir tasarÄ±m yapmak iÃ§in MVC design paternâ€™Ä± araÅŸtÄ±rabilirsiniz.\nEvet ÅŸimdi 3. adÄ±ma geÃ§tik backend kodlarÄ± yazmaya baÅŸlÄ±yoruz. Backend kodu ile kastetmek istediÄŸim logic katmandÄ±r. KodlarÄ± burda yazarak gitmek isterdim fakat o kadar bir vakit olmadÄ±ÄŸÄ± iÃ§in burayÄ± tabiki siz yazacaksÄ±nÄ±z. Hadi 4. adÄ±mÄ± inceleyelim. Teslim alÄ±nan telemetri verisini arayÃ¼zde bulunan yerlerine atama yapmanÄ±z gerekiyor. Bu telemetri verilerini nasÄ±l teslim alÄ±nÄ±yormuÅŸ gibi yapÄ±yoruz ona bakalÄ±m. Bu yÃ¶ntem aslÄ±nda Test Driven Development(TTD) ile oldukÃ§a benzerdir. Mesela biz saat, tarih, batarya verisini aldÄ±k diyelim.\n\r\nYukarÄ±da 3 tane kÄ±rmÄ±zÄ± kutucuk var ve bu kutucuklar iÃ§erisine text ekleyebileceÄŸimiz kutulardÄ±r. Bu kutularÄ±n iÃ§erisine Ã¶rnek olmasÄ± amacÄ±yla veriler yazdÄ±m. Biz teslim aldÄ±ÄŸÄ±mÄ±z saat, tarih ve batarya verisini buralara atayacaÄŸÄ±z. DiÄŸer kÄ±sÄ±mlarÄ±da aynÄ± ÅŸekilde yapÄ±yoruz.\nEvet 4. adÄ±mÄ±da geÃ§tik ÅŸimdi artÄ±k telemetri verilerini teslim alabiliriz. Buraya kadar herÅŸey sadece basit bir temel oluÅŸturmak iÃ§indi Ã§Ã¼nkÃ¼ veriyi nasÄ±l kullanacaÄŸÄ±mÄ±zÄ± bilerek verileri teslim almak daha rahat ve performanslÄ± kod yazmamÄ±za yardÄ±mcÄ± olur. ÅŸimdi artÄ±k asÄ±l meselemize geÃ§me vakti geldi.\nHaberleÅŸme Ä°lk olarak haberleÅŸme nasÄ±l yapÄ±lÄ±r sorusuna cevap verelim.\nCihaz ile hostu(Ã¶rn. Bilgisayar) haberleÅŸtirmek iÃ§in kullanÄ±lan birden fazla haberleÅŸme Ã§eÅŸiti vardÄ±r. Bunlar Seri HaberleÅŸme, Ethernet ve Bluetooth olabilir. Hadi biz seri haberleÅŸem kullanalÄ±m. Peki seri haberleÅŸme nasÄ±l oluyor. Seri haberleÅŸme klasik, bilgisayarÄ±n portu ile micro denetleyici arasÄ±nda kulladÄ±ÄŸÄ±nÄ±z USB kablosu(genellikle RS232) ile yapÄ±lan haberleÅŸmedir. Herkesin rahatlÄ±kla temin edip, basit kodlama ve protatip Ã¼retmek amacÄ±yla Arduino kullanÄ±larak kodlama yapÄ±lacaktÄ±r. MantÄ±k her ortam iÃ§in geÃ§erlidir.\n\r\nHaberleÅŸme tÃ¼rÃ¼nÃ¼ seÃ§tik hadi Ã¶yleyse haberleÅŸmeye geÃ§elim.\nÄ°lk olarak Arduinoâ€™da kullanÄ±lan saÄŸ Ã¼st kÃ¶ÅŸede bulunan seri port ekranÄ±nÄ± herkes bilir. Bunun seri iletiÅŸim yaparak seri ekrana veriyi bastÄ±ÄŸÄ±nÄ± bilen kaÃ§ kiÅŸi var. Seri port ekranÄ± debug iÅŸlemi yapmamÄ±zÄ± saÄŸlayan bir Ã¶zellik. Peki bu arduino iÃ§erisinde Ã§alÄ±ÅŸan kodu nasÄ±l oluyorda bizim bilgisayar ortamÄ±nda gÃ¶zlemlememizi saÄŸlÄ±yor olabilir? Konunun sonunda haberleÅŸeme ile ilgili kafanÄ±zda pek soru iÅŸareti kalmayacaktÄ±r.\nElimizde temperature verisi var ve biz bunu Serial.println() ile seri port ekranÄ±na 1snâ€™ de bir basÄ±yor olalÄ±m. Bu bizim haberleÅŸme de kullanacaÄŸÄ±mÄ±z ilk ve en basit yoldur.\nconstÂ intÂ temperatureÂ =Â 28; voidÂ setup()Â { Serial.begin(9600); } voidÂ loop()Â { Serial.print(\u0026#34;TemperatureÂ =Â \u0026#34;); Serial.println(temp); delay(1000); } Ä°lk haberleÅŸmemizi gerÃ§eleÅŸtirdik. GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi Ã§ok basit bir ÅŸekilde veriyi bilgisayar ortamÄ±na aktardÄ±k ve serial port ekranÄ± aracÄ±lÄ±ÄŸÄ± ile Temperature deÄŸerini gÃ¶zlemledik. Peki iÅŸlem nasÄ±l gerÃ§ekleÅŸti. Tabi ki Arduino Ideâ€™si biz seri ekranÄ± aÃ§tÄ±ÄŸÄ±mÄ±z anda farkÄ±nda olmadan veriyi arduinodan 9600 baudrate hÄ±zÄ±nda baÄŸlantÄ± kurarak teslim aldÄ±. Bizim yazacaÄŸÄ±mÄ±z arayÃ¼z bu mantÄ±kla seri port ekranÄ±na benziyor demi? Bizde arayÃ¼zÃ¼ tasarlarken seri porttan faydalanabiliriz.\nO zaman seri port ekranÄ±nÄ± gÃ¶zlemleyelim. Baudrate hÄ±zÄ±nÄ± ayarlamak iÃ§in bir adet combo box var. Buradan Arduino ile bilgisayar ortamÄ± arasÄ±ndaki haberleÅŸeme hÄ±zÄ±nÄ± seÃ§iyoruz. Arduinoda yazdÄ±ÄŸÄ±mÄ±z haberleÅŸme hÄ±zÄ± Serial.begin(9600) ile aynÄ± olmalÄ±dÄ±r. Turuncu kutucuk \u0026ldquo;Yeni satÄ±r\u0026rdquo;, \u0026ldquo;starÄ± baÅŸÄ±\u0026rdquo;, \u0026ldquo;NL ve CR ile birlikte\u0026rdquo; olmak Ã¼zere monitordan arduinoya veri gÃ¶nderirken satÄ±r sonuna eklenecek opsiyonlarÄ± iÃ§erir.\n\r\n Not: Arduino Ideâ€™si Java ile yazÄ±lmÄ±ÅŸtÄ±r.\n Evet ilk Ã¶rneÄŸimizi yaptÄ±k ve ekranda deÄŸerimizi gÃ¶zlemledik. Ã–ncellikle tÃ¼m verilerimizi bu ÅŸekilde tasarladÄ±ÄŸÄ±mÄ±z arayÃ¼ze gÃ¶nderebiliz hadi bir kaÃ§ veri daha ekleyip nasÄ±l bir iÅŸlem gerÃ§ekleÅŸeceÄŸini gÃ¶zlemliyelim.\nfloatÂ temperatureÂ =Â 28; floatÂ humidityÂ =Â 50; longÂ timestampÂ =Â 12450; voidÂ setup()Â { Serial.begin(9600); } voidÂ loop()Â { Serial.print(temperature); Serial.print(\u0026#39;,â€™); Serial.print(humidity); Serial.print(\u0026#39;,â€™); Serial.println(timestamp); delay(1000); } Farz edelim ki 3 veriyi sensÃ¶rden okuduk ve arayÃ¼zde okumak iÃ§in bilgisayar ortamÄ±na gÃ¶nderdik. Hadi arayÃ¼ze geÃ§ip bunlarÄ± nasÄ±l okuyacaÄŸÄ±mÄ±za bakalÄ±m. Daha sonra bu Ã¶rneÄŸimizin eksilerini artÄ±larÄ± belirleyip daha iyi hale nasÄ±l getireceÄŸimize bakalÄ±m.\nSizlere haberleÅŸme yapÄ±lÄ±rken bir kaÃ§ problemden daha bahsetmek istiyorum.\n  HaberleÅŸme sÄ±rasÄ±nda veri kaybÄ± yaÅŸamak.\nVeri kaybÄ± olmasÄ± durumunda ne olur tabiki gÃ¶nderilen sÄ±ra bozulur istenilen uzunlukta bir array elde edilmez ve arrayÄ±n son adresine ulaÅŸmaya Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda segmatation fault hatasÄ± almak kaÃ§Ä±nÄ±lmaz olur. Buda program sonlandÄ±rÄ±r.\n  HaberleÅŸme sÄ±rasÄ±nda herhangi bir bit deÄŸiÅŸmesi.\nBitin deÄŸiÅŸmesi progrmamÄ±n Ã§alÄ±ÅŸmasÄ±na mani olmaz ancak verinin yanlÄ±ÅŸ olacaÄŸÄ± ve anlÄ±k deÄŸiÅŸimlerin olacabileceÄŸi Ã¶zellikle grafik Ã§izimlerinde saÃ§ma sapan artÄ±ÅŸ azalÄ±ÅŸlarÄ±n gÃ¶zlemlenmesine sonuÃ§ olacaktÄ±r.\n  AynÄ± mesaj iÃ§inde farklÄ± bilgiler gÃ¶ndermek.\n  FarklÄ± platformlar arasÄ± veri akÄ±ÅŸÄ± saÄŸlamak.\n  DonanÄ±mdan baÄŸÄ±msÄ±zlaÅŸtÄ±rmak.\n  AslÄ±nda bu problem size protokol(Json,XML,NanoPb..) kullanmak zorunda bÄ±rakÄ±yor. Yine de protokollere geÃ§meden sizelere protokolerle geÃ§iÅŸ esnasÄ±na kadar neden bu protokoller kullanmak zorunda kaldÄ±ÄŸÄ±mÄ±zÄ± Ã¶rnekler Ã¼zerinde gÃ¶stereceÄŸim. Tabi protocol kullanmak zorunda deÄŸilsiniz ama kullanmak istemiyorsanÄ±z tÃ¼m bu problemleri kendiniz Ã§Ã¶zmek zorunda kalacaksÄ±nÄ±z.\nAncak bunlarÄ±n hepsini kendiniz deneyerek gÃ¶zlemlerseniz Ã§ok daha akÄ±lda kalÄ±cÄ± olacak ve daha iyi anlaÅŸÄ±lacakdÄ±r.\nArtÄ±k ilk Ã¶rneÄŸimizi geliÅŸtirme zamanÄ± geldi.\nSerial.print() yerine artÄ±k Serial.write() kullanalÄ±m.\nBunun sebebi Serial.print() text tabanlÄ±(formatlÄ±) akatarÄ±m yapmasÄ±na karÅŸÄ±n Serial.write() binary tabanlÄ±(formatsÄ±z) aktarÄ±m yapmasÄ±dÄ±r buda bizlere Ã§ok daha performanslÄ± iÅŸlem saÄŸlayacaktÄ±r.\nstructÂ DataÂ { floatÂ temperature; floatÂ humidity; longÂ timestamp; }data; Data adÄ±nda bir struct oluÅŸturduk bu veri listemizi paketledik. AynÄ± mesaj iÃ§erisinde farklÄ± verilerin transferini bu ÅŸekilde saÄŸlÄ±yoruz.\nHadi sensÃ¶rden gerekli bilgileri okuduk ÅŸimdi bunu bilgisayara gÃ¶nderelim.\n1.\tSerial.write(\u0026amp;data,sizeof(data)); 2. DataÂ *ptrÂ =Â \u0026amp;data; for(intÂ iÂ =Â 0;Â iÂ \u0026lt;Â sizeof(data);Â i++) { Serial.write(*ptr++); }  Bir mesaj paketini struct iÃ§erisine eklerken dikkat edilmesi gereken bir diÄŸer konu alignment\u0026rsquo;tir. Derleyici siz farkÄ±nda olmadan veri yapÄ±nÄ±zÄ± daha hÄ±zlÄ± Ã§alÄ±ÅŸabilmesi adÄ±na ekstra byte\u0026rsquo;lar ekliyor olabilir.\n Bu iki yÃ¶ntemde verimizi karÅŸÄ± tarafa iletmemizi saÄŸlar. Bunlar dediÄŸim gibi binary formatta taÅŸÄ±nÄ±r ve karÅŸÄ± tarafta deserialize iÅŸlemi binary formatta gerÃ§ekleÅŸir. Ä°lk Ã¶rnekle arasÄ±nda ne fark var? Ä°lk olarak text tabanlÄ± bir haberleÅŸme deÄŸil, daha sonra parse iÅŸlemi yapmayÄ± gerektirmiyor Ã§Ã¼nkÃ¼ zaten veri bilgisayara binary formatta bilgisayarÄ±n dilinde gÃ¶nderdik. Sadece yapÄ±lmasÄ± gereken ilgili deÄŸerin tipini belirtmek.\nPeki bunda ne gibi problemler var?\n  TaÅŸÄ±nabilir deÄŸil.\n  Rigid bir yapÄ±ya sahip.\n  ArtÄ±larÄ± ise;\n  Basittir.\n  PerformanslÄ±dÄ±r.\n  GÃ¼venlidir.\n  TaÅŸÄ±nabilirlikten kastÄ±m nedir?\nÃ–rneÄŸin, timestamp deÄŸiÅŸkeninin tipi longâ€™tur.\nLong Arduinoâ€™da 4 byte yer kaplar.\nLinux 64-bit iÅŸletim sisteminde 8 byte yer kaplar.\nBu bize gÃ¶steriyor ki bu veriyi karÅŸÄ± tarafa gÃ¶nderirken platforma baÄŸÄ±mlÄ± oluyoruz. Yani karÅŸÄ± tarafa diyorum ki bak ben sana veri gÃ¶nderdim bunun boyutu 4 byte ama sen platformun Ã¶zelliklerini bilmeden bunu long tipinden bir deÄŸiÅŸkene yazarsan sonuÃ§ beklediÄŸin gibi olmayabilir.\nRigid olmasÄ± herhangi bir deÄŸiÅŸiklikte bilgisayar tarafÄ±ndaki kodu da deÄŸiÅŸtirmeye gerek olmamasÄ± durumudur.\n   Temperature Humidity Timestamp     4 bytes 4 bytes 4 bytes    Peki long tipini nasÄ±l olurda platformdan baÄŸÄ±msÄ±z hale getirilebilir?\nTabiki int32_t kullanarak bunu her platformda 4 byte olacaÄŸÄ±nÄ± garanti edebiliriz. O zaman struct bu ÅŸekilde olacaktÄ±r;\nstructÂ DataÂ { floatÂ temperature; floatÂ humidity; int32_tÂ timestamp; }data; ArtÄ±k verileri platformdan baÄŸÄ±msÄ±z hale getirdik ama hale bilmemiz gereken bir ÅŸey daha var ki bu da Endianessâ€™ tÄ±r.\nYani byteâ€™larÄ±n sÄ±ralanÄ±ÅŸ biÃ§imidir ve iki tÃ¼rlÃ¼ endiannessâ€™ vardÄ±r. Bunlar Little Endiean(LSB) ve Big Endian(MSB)â€™dÄ±r. Ve Ã§oÄŸunlukla big endian tercih edilir. Åimdi bunlar nerden Ã§Ä±ktÄ± diyorsunuzdur. Binary iÅŸlem yapÄ±yoruz tabiki bytelarÄ±n sÄ±ralanÄ±ÅŸ biÃ§imleri bizim iÃ§in oldukÃ§a Ã¶nem arz etmektedir. Fakat bunun iÃ§in herhangi bir iÅŸlem ÅŸuan yapmayacaÄŸÄ±z.\nHadi devam edelim ve struct yapÄ±mÄ±za karakter taÅŸÄ±yan bir deÄŸiÅŸken ekleyelim.\nstructÂ DataÂ { floatÂ temperature; floatÂ humidity; int32_tÂ timestamp; charÂ location[16]; }data; data.locationÂ =Â \u0026#34;LivingÂ Room\u0026#34;;Â //Error Tabi ki char[16] tipindeki location deÄŸiÅŸkenine , const char[12] tipinde tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼ olacaÄŸÄ±ndan atama yapamayÄ±z.\nstrcpy(data.location,\u0026#34;Living Room\u0026#34;); Bu ÅŸekilde location deÄŸerine atama yapabiliriz.\nFakat yazmak istediÄŸimiz verinin bÃ¼yÃ¼k olmasÄ±na karÅŸÄ±n overflowâ€™dan kaÃ§Ä±nmamÄ±z gerekecektir.\nstrlcpy(data.location,\u0026#34;Living Room\u0026#34;,16); Fonksiyonun son parametresine boyutunu vererek bu boyuttan fazla yere eriÅŸme bu kadar yere olan kÄ±sma kadar tek yaz diyoruz.\nPeki buradaki problem ne?\nProblemlerimize ekstra olarak overhead(aÅŸÄ±rÄ± yÃ¼kleme) oluÅŸabilir. Mesela bir karakter gÃ¶ndermek istiyorum fakat karÅŸÄ± tarafa gÃ¶nderilirken 16 byte aktarÄ±m yapÄ±lÄ±r sadece ilk karakter dolu diÄŸerleri boÅŸ olacaktÄ±r. Buda gereksiz yere 15 byte veri transfer etmemiz anlamÄ±na gelir.\n   Temperature Humidity Timestamp Location     4 bytes 4 bytes 4 bytes 16 bytes    Hadi overhead engelleyip yolumuza devam edelim.\nstructÂ DataÂ {Â floatÂ temperature; floatÂ humidity; longÂ timestamp; uint8_tÂ location_len; }data; charÂ location[16]; Location deÄŸiÅŸkenini structâ€™tan dÄ±ÅŸarÄ± Ã§Ä±kardÄ±k ve location deÄŸerinin boyutu teslim etmesi iÃ§in location_len ekledik.\nPeki bunu nasÄ±l bilgisayara gÃ¶ndereceÄŸiz?\nstrlcpy(location,\u0026#34;LivingÂ Room\u0026#34;,16); data.location_lenÂ =Â strlen(location); Serial.write(\u0026amp;data,sizeof(data)); Serial.write(location,data.location_len); GÃ¶ndereceÄŸimiz karakterin Ã¶ncellikle ne kadar bir boyutu var onu alÄ±yoruz. Daha sonra location_len deÄŸiÅŸkenine bu boyutu atatÄ±ktan sonra karakterimizi gÃ¶nderiyoruz.\n   Temperature Humidity Timestamp Location_len Location     4 bytes 4 bytes 4 bytes 1 bytes 11 bytes    Bazen farklÄ± verileri transfer edebiliyoruz. Bunun iÃ§in ayrÄ± bir tane daha struct oluÅŸturabiliriz.\nstructÂ format_V1Â {Â floatÂ temperature; floatÂ humidity; longÂ timestamp; }; structÂ format_V2Â {Â floatÂ temperature;Â floatÂ humidity;Â longÂ timestamp;Â floatÂ pressure; }; structÂ Data{Â uint8_tÂ version; unionÂ {Â format_V1Â v1;Â format_V2Â v2;Â }; }data; Data structâ€™Ä±nÄ± artÄ±k istediÄŸimiz veriyi transfer etmesi iÃ§in union ile sardÄ±k. Union kullanmamÄ±zÄ±n nedini hafÄ±zada ekstra yer kaplamamak. Hadi bunu transfer edelim.\nSerial.write(\u0026amp;data.version,1); if(data.version==1)Â Serial.write(data.v1,sizeof(format_V1)); elseÂ Serial.write(data.v2,sizeof(format_V2));    Version Temperature Humidity Timestamp Pressure     **(V1)**1 byte 4 bytes 4 bytes 4 bytes 0 bytes   **(V2)**1 byte 4 bytes 4 bytes 4 bytes 4 bytes    Åuana kadar neler yaptÄ±k?\nText tabanlÄ± formattan, binary formata geÃ§iÅŸ yaptÄ±k bu da bize run timeâ€™da parse ve tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼ esnasÄ±nda olacak zaman kayÄ±plarÄ±nÄ± minimize etti. Veriler binary olarak depolandÄ±ÄŸÄ± iÃ§inde hafÄ±za da Ã§ok daha az yer kapladÄ±. Bunlarla birlikte daha performanslÄ± bir iletiÅŸim saÄŸlamÄ±ÅŸ olduk.\nAyrÄ±ca serileÅŸtirdiÄŸimiz kodlar;\nâœ… Ã‡oklu deÄŸiÅŸkenleri depolayÄ±p, gÃ¶nderebilir.\nâœ… String dizi deÄŸiÅŸkenlerini destekler.\nâœ… FarklÄ± platformalarda Ã§alÄ±ÅŸabilir.\nâœ… Birden fazla versiyonu destekler.\nâŒ OldukÃ§a karÄ±ÅŸÄ±k ve zaman aldÄ±.\nBuraya kadar az Ã§ok serileÅŸtirmeyi verilerimizi bilgisayar ortamÄ±na nasÄ±l gÃ¶ndereceÄŸimizi inceledik. ArtÄ±k protokollere geÃ§menin zamanÄ± gelmedi mi?\nProtokoller bizim yerimize tÃ¼m bu iÅŸlemleri platformadan baÄŸÄ±msÄ±z hale getirmesi gibi bir Ã§ok artÄ± yÃ¶nlerini inceleyeceÄŸiz.\nKullanÄ±lacak protokoller;\n  XML\n  JSON\n  NanoPb olacaktÄ±r.\n  Fakat bir ÅŸeyi fark ettiniz. HaberleÅŸme problemlerini belirttiÄŸim 2 problem Ã¼zerinde hiÃ§ durmadÄ±k. Ä°lk problem haberleÅŸme esnasÄ±nda ki veri kaybÄ± diÄŸeri ise haberleÅŸme esnasÄ±nda ki herhangi bir bitâ€™in deÄŸiÅŸmesi. Bu iki problem Ã¼zerinde durmama nedenim kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ± olmamasÄ± iÃ§indi. Fakat bunun iÃ§in sÄ±klÄ±kla kullanÄ±lan Cyclic Redundancy Code (CRC) methotuna daha sonra deÄŸinir ve gerekli Ã¶nlemlerimizi almÄ±ÅŸ olacaÄŸÄ±z. Ancak eminim ki sizlerde bunlarla uÄŸraÅŸmak istemiyeceksinizdir. Ä°ÅŸte tamda bunun iÃ§in sizlere protokolerden bahsetmek istiyorum Ã‡Ã¼nkÃ¼ kodumuzu oldukÃ§a karmaÅŸÄ±k hale geldi ve veri transfer ederken bilgisayar ortamÄ±nda bu verilerin doÄŸru aktrÄ±ldÄ±mÄ± kontrolÃ¼ ile uÄŸraÅŸmak hakikatan oldukÃ§a zaman alan iÅŸlemler. Protokoller bizler iÃ§in bu problemleri Ã§Ã¶zÃ¼yor. Bize kalan ise sadece protokolÃ¼n uyulmasÄ± gereken kurallarÄ±nÄ± Ã¶ÄŸrenmek. Zaten protokolÃ¼n manasÄ±da uyulmasÄ± gereken kurallar. Peki bu 3 protokolâ€™Ã¼n 3 de aynÄ± gÃ¶revi yapmasÄ± karÅŸÄ±n farklarÄ± nelerdir? Ã–ncellikle XML bildindiÄŸi Ã¼zere human readable bir format ve text tabanlÄ± bir iletiÅŸimdir. AynÄ± ÅŸekilde Jsonâ€™da XML gibidir. Ancak aralarÄ±ndaki en Ã¶nemli fark Json daha okunaklÄ± bir yapÄ±sÄ± olmasÄ±nÄ±n yanÄ±nda hafÄ±zada daha az yer kaplar. Buda Json iletiÅŸiminin Xmlâ€™den daha hÄ±zlÄ± olacaÄŸÄ±nÄ± gÃ¶steriyor. Peki bu NanoPbâ€™de neyin nesi? Protocol Buffer google tarafÄ±ndan geliÅŸtirilen bir protocolâ€™dÃ¼r ve NanoPbâ€™ye oldukÃ§a benzerdir. NanoPb Ã§ok daha hÄ±zlÄ± iletiÅŸim saÄŸlayan hatta bizim kendi yazdÄ±ÄŸÄ±mÄ±z binary formattaki iletiÅŸimden de daha hÄ±zlÄ± bir iletiÅŸim saÄŸlayan bir prokoldÃ¼r. Bunun nasÄ±l olduÄŸunu elbette NanoPbâ€™yi anlatÄ±rken gÃ¶receÄŸiz.\nOldukÃ§a sÄ±k kullanÄ±lan bir protocol olmasÄ±nÄ±n yanÄ±nda arkasÄ±nda Google gibi bir geliÅŸtirici olmasÄ± bu protokolÃ¼n Ã¶nemli Ã¶zelliklerindendir. Google kendi iÃ§inde ki haberleÅŸmeyi hÄ±zlÄ± ve gÃ¼venilir bir ÅŸekilde aktarmak iÃ§in bu protokolÃ¼ geliÅŸtirdi.\nEvet sonunda ilk protokolÃ¼mÃ¼ze geÃ§miÅŸ bulunmaktayÄ±z. UmarÄ±m ÅŸuana kadar anlatÄ±lanlar en azÄ±nÄ±zdan temel dÃ¼zeyde kafanÄ±zda oturtmanÄ±za yardÄ±mcÄ± olmuÅŸtur. Buraya kadar iletiÅŸim noktasÄ±nda Ã§oÄŸu ÅŸeyden bahssettik. Fakat hala anlatmadÄ±ÄŸÄ±m senkron, asekron ve gerÃ§ek zamanlÄ± iletiÅŸim gibi olmazsa olmazÄ±mÄ±z olmasÄ± gereken iletiÅŸim yapÄ±larÄ±ndan bahsetmedim. Bunun iÃ§in detaylÄ± bir anlatÄ±mÄ± protokollerden sonra anlatacaÄŸÄ±m. AsÄ±l kullanacaÄŸÄ±mÄ±z protokol Nanopb olacak ama neden onu kullandÄ±ÄŸÄ±mÄ± anlamanÄ±z iÃ§in anlatacaÄŸÄ±m diÄŸer protokolleride incelemenizi tavsiye ediyorum. Hadi Ã¶yleyse XML protokolÃ¼ ile baÅŸlayalÄ±m.\nXML XML (Extensible Markup Language ya da TÃ¼rkÃ§esiyle GeniÅŸletilebilir Ä°ÅŸaretleme Dili), hem insanlar hem bilgi iÅŸlem sistemleri tarafÄ±ndan kolayca okunabilecek dokÃ¼manlar oluÅŸturmaya yarayan bir iÅŸaretleme dilidir. W3C tarafÄ±ndan tanÄ±mlanmÄ±ÅŸ bir standarttÄ±r. Bu Ã¶zelliÄŸi ile veri saklamanÄ±n yanÄ±nda farklÄ± sistemler arasÄ±nda veri alÄ±ÅŸveriÅŸi yapmaya yarayan bir ara format gÃ¶revi de gÃ¶rÃ¼r. Ä°nternet Ã¼zerinde bir Ã§ok veri XML ile taÅŸÄ±nÄ±r peki biz bunu donanÄ±m ile bilgisayar arasÄ±nda gerÃ§ekleÅŸtirebilir miyiz? Ã–ncelikle XML metinsel bir veri formatÄ±dÄ±r bu nedenle taÅŸÄ±nacak verilerin boyutu olaÄŸandan daha bÃ¼yÃ¼k olacak bu da bizim veri iletiÅŸim hÄ±zÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼recektir.\nÃ–rneÄŸin;\n\u0026lt;data\u0026gt; \u0026lt;temperature\u0026gt;21.2\u0026lt;/temperature\u0026gt; \u0026lt;humidity\u0026gt;48\u0026lt;/humidity\u0026gt; \u0026lt;timestamp\u0026gt;1025\u0026lt;/timestamp\u0026gt; \u0026lt;/data\u0026gt; Bu Ã¶rnekte temperature, humidity, timestamp verilerimizi XML formatÄ±nda nasÄ±l temsil edildiÄŸini gÃ¶rdÃ¼k. Hadi bu formatÄ± arduino Ã¼zerinde nasÄ±l Ã§alÄ±ÅŸtÄ±rabiliriz ona bakalÄ±m.\nSerial.print(\u0026#34;\u0026lt;data\u0026gt;\u0026lt;temperature\u0026gt;\u0026#34;); Serial.print(temperature); Serial.print(\u0026#34;\u0026lt;/temperature\u0026gt;\u0026#34;); Serial.print(\u0026#34;\u0026lt;humidity\u0026gt;\u0026#34;); Serial.print(humidity); Serial.print(\u0026#34;\u0026lt;/humidity\u0026gt;\u0026#34;); Serial.print(\u0026#34;\u0026lt;timestamp\u0026gt;\u0026#34;); Serial.print(timestamp); Serial.print(\u0026#34;\u0026lt;/timestamp\u0026gt;\u0026lt;/data\u0026gt;\u0026#34;); Bunu bÃ¶yle gÃ¶nderdik ama bunun bilgisayar ortamÄ±nda okunduktan sonra nasÄ±l ayrÄ±ÅŸtÄ±rÄ±lacaÄŸÄ±na(deserializa) girmiyorum Ã§Ã¼nkÃ¼ her dil iÃ§in mantÄ±k aynÄ± olsa da kodlar farklÄ±lÄ±k gÃ¶sterecektir. Fakat bu ÅŸekilde veriyi transfer etmenin bize getireceÄŸi sorunlarÄ± baÅŸta Ã§okca bahsetmiÅŸtim. Peki bunu nasÄ±l geliÅŸtirebiliriz. Ã–ncelikle bu ÅŸekilde transfer etmenin daha sonra sÄ±rada herhangi bir verinin sÄ±rasÄ± deÄŸiÅŸmesi durumunda bilgisayar ortamÄ±nda ki deserializa iÅŸleminide etkileyeceÄŸinden arduino iÃ§in geliÅŸtirilmiÅŸ kÃ¼tÃ¼phane olan libxml2 kÃ¼tÃ¼phanesini kullanarak bunu Ã¶nleyelim.\n    Temperature Humidity Timestamp      6 bytes 31 bytes 23 bytes 28 bytes 7 bytes    Bu ÅŸekilde totalde 95 byte, baÅŸta bizim tasarladÄ±ÄŸÄ±mÄ±zdan %700 daha fazla byte taÅŸÄ±mÄ±ÅŸ olacaÄŸÄ±z.\n#includeÂ \u0026lt;libxml/parser.h\u0026gt;#includeÂ \u0026lt;libxml/tree.h\u0026gt;StringÂ bufferÂ =Â Serial.readString(); xmlDoc*Â docÂ =Â xmlReadMemory(buffer.data(), buffer.size(),\u0026#34;nanome.xml\u0026#34;,NULL,0); xmlNode*Â rootÂ =Â xmlDocGEtRootElement(doc); for(xmlNode*Â nodeÂ =Â root-\u0026gt;children;Â node;Â nodeÂ =Â node-\u0026gt;next) { char*Â keyÂ =Â reinterpret_cast\u0026lt;char*\u0026gt;(node-\u0026gt;name); char*Â valueÂ =Â reinterpret_cast\u0026lt;char*\u0026gt;(xmlNodeGetContent(node)); if(strcmp(key,\u0026#34;temperature\u0026#34;))Â { temperatureÂ =Â atof(value);Â //atof(\u0026#34;21.2\u0026#34;)Â =Â 21.2 Â } elseif(strcmp(key,\u0026#34;humidity\u0026#34;))Â { humidityÂ =Â atof(value); } elseif(strcmp(key,\u0026#34;timestamp\u0026#34;))Â { timestampÂ =Â *(reinterpret_cast\u0026lt;uint32_t*\u0026gt;(value)); } } xmlFreeDoc(doc); XML kÃ¼tÃ¼phanesinin artÄ±larÄ±;\n  Esnek\n  TaÅŸÄ±nabilir\n  Okunabilir\n  Daha kÄ±sa bir Ã¶nceki XML\u0026rsquo;de elle yazdÄ±ÄŸÄ±mÄ±za gÃ¶re.\n  Bu yapÄ±yÄ± kullanmanÄ±zÄ± tavsiye etmiyorum sadece genel olarak bir fikir edinmesi iÃ§in deÄŸindi.\nBu yapÄ± ile birlikte donanÄ±mdan baÄŸÄ±msÄ±z olmuÅŸ oluyorsunuz lakin telemetri boyutu oldukÃ§a bÃ¼yÃ¼dÃ¼.\nBir diÄŸer protokollÃ¼mÃ¼z olan Json formatÄ±na geÃ§elim ve XML ile arasÄ±ndaki artÄ±larÄ±nÄ± ve eksilerini gÃ¶zlemliyelim.\nJSON JSON, aÃ§Ä±lÄ±mÄ± Javascript Object Notation olan, Key-Value (anahtar-deÄŸer) Ã§iftlerinden oluÅŸan metin biÃ§imidir ve veri depolamak veya veri transferi gibi iÅŸlemler iÃ§in kullanÄ±lmaktadÄ±r. XML ile benzerlik gÃ¶stermekle birlikte, XMLâ€™den daha basit ve hÄ±zlÄ± Ã§alÄ±ÅŸmakta, yapÄ±sÄ± itibariyle de daha kÃ¼Ã§Ã¼k boyutlu veriler yazÄ±labilmektedir. JSON Javascriptâ€™ten esinlenilerek yapÄ±lmÄ±ÅŸsada, diÄŸer programlama dillerinden baÄŸÄ±msÄ±z olarak Ã§alÄ±ÅŸmaktadÄ±r.\nJSONâ€™un YapÄ±sÄ± NasÄ±ldÄ±r?\nJson 6 tane veri tipine sahiptir.\n  Number\n  String\n  Array: \u0026ldquo;name\u0026rdquo;: [â€¦] ÅŸeklinde kullanÄ±lÄ±r.\n  Boolean: true|false\n  Object: \u0026ldquo;name\u0026rdquo;: {..} ÅŸeklinde kullanÄ±lÄ±r.\n  Null\n  JSON ve XML ArasÄ±ndaki Farklar Nelerdir**?**\n  XMLâ€™de ve ile elementler tanÄ±mlanÄ±r. JSON da ise element { .. } ÅŸeklindedir.\n  JSON Ã§Ä±kÄ±ÅŸ noktasÄ± Javascript iken , XML markup dillerinden Ã§Ä±kmÄ±ÅŸtÄ±r.\n  JSON, Javascriptâ€™in dilinin bir Ã¶zelliÄŸidir ve Javascript tarafÄ±ndan desteklenmektedir.\n  JSONâ€™un , XMLâ€™e gÃ¶re daha kÄ±sa yazÄ±lÄ±r ve daha kolay okunabilmektedir.\n  JSONâ€™da dizi desteÄŸi vardÄ±r. XMLâ€™de bÃ¶yle bir kavram yer almamaktadÄ±r.\n  JSON, XMLâ€™e gÃ¶re daha hÄ±zlÄ±dÄ±r ve daha kÃ¼Ã§Ã¼ktÃ¼r.\n  JSON, XML gibi geliÅŸtirilebilir bir yapÄ± deÄŸildir.\n  Bu iki protokol web ortamÄ±nda verileri transfer etmek iÃ§in oldukÃ§a fazla kullanÄ±lÄ±r. Peki biz bu protokolleri dÃ¼ÅŸÃ¼k seviyeli sistemlerde neden tercih etmeliyiz? Ã–ncellikle IOT alanÄ±nda bir cihazÄ±nÄ±z varsa ve bunu belirli bir zamanda hosta gÃ¶ndermek istediÄŸiniz zaman bu protokollÃ¼ kullanabilirisiniz lakin IOT\u0026rsquo;Ä± iÃ§in geliÅŸtirmiÅŸ bir protokol olan Mqtt protokolu Ã§ok daha fazla kullanÄ±lÄ±r. Sizin Ã¶ncellikle veriyi transfer ederken verinizin kaÃ§ saniyede teslim edileceÄŸini bilmeniz gerekir. EÄŸer ki sÃ¼rekli olarak verileri bilgisayar ortamÄ±na gÃ¶nderirseniz(buna asynchronous communication denir) o zaman bu protokoleri kullanmak sizin iÃ§in uygun olmayacaktÄ±r. Fakat veriler TÃ¼rksat Model Uydu yarÄ±ÅŸmasÄ±ndaki gibi 1sn de bir veya daha yavaÅŸ(Ã¶rn. 5sn) gÃ¶nderilecekse bu protokkolerin kullanÄ±lmasÄ±nda bir sakÄ±nca yoktur. Hemen ilk Ã¶rneÄŸimizdeki verileri Json formatÄ±nda nasÄ±l teslim edileceÄŸini gÃ¶zlemleyelim.\n{ \u0026#34;temperature\u0026#34;:Â 21.2, \u0026#34;humidity\u0026#34;:Â 48, \u0026#34;timestamp\u0026#34;:Â 40021 } Bunu kÃ¼tÃ¼phane kullanmadan nasÄ±l gÃ¶ndereceÄŸize bakalÄ±m daha sonra kÃ¼tÃ¼phane kullanacaÄŸÄ±z.\nSerial.print(\u0026#34;\\{\\\u0026#34;temperature\\\u0026#34;:\u0026#34;); Serial.print(temperature); Serial.print(\u0026#34;,\\\u0026#34;humidity\\\u0026#34;:\u0026#34;); Serial.print(humidity); Serial.print(\u0026#34;,\\\u0026#34;timestamp\\\u0026#34;:\u0026#34;); Serial.print(timestamp); Serial.print(\u0026#34;\\}\u0026#34;);    {,,,} Temperature Humidity Timestamp     5 bytes 18 bytes 13 bytes 17 bytes    Totalde 53 byte veri aktarÄ±mÄ± yapÄ±yor olcaÄ±ÄŸÄ±z bu XML\u0026rsquo;e gÃ¶re 42 byte daha az byte kullanarak veri aktarmak demek. Bu ÅŸekilde veriyi gÃ¶ndermek XML\u0026rsquo;de ve ilk Ã¶rneÄŸimizde olduÄŸu gibi sÄ±ra deÄŸiÅŸmesi halinde arayÃ¼z yazÄ±lÄ±mÄ±nda da aynÄ± sÄ±raya gÃ¶re deserializa iÅŸlemi yapÄ±lmak zorunda. Bunun iÃ§inde Arduino\u0026rsquo;daki Json kÃ¼tÃ¼phanesi kullanabiliriz.\nArduinoJSON\n OldukÃ§a popÃ¼ler bir arduino kÃ¼tÃ¼phanesidir. Her C++ projesi ile Ã§alÄ±ÅŸÄ±r. GÃ¶mÃ¼lÃ¼ sistemler iÃ§in optimize edilmiÅŸtir. Daha dÃ¼ÅŸÃ¼k hafÄ±za kullanÄ±mÄ± saÄŸlar. Daha dÃ¼ÅŸÃ¼k cpu kullanÄ±mÄ± saÄŸlar. Test edilmiÅŸtir.  //Serialization StaticDocument\u0026lt;200\u0026gt;Â doc; doc[\u0026#34;temperature\u0026#34;]Â =Â temperature; doc[\u0026#34;humdity\u0026#34;]Â =Â humdity; doc[\u0026#34;timestamp\u0026#34;]Â =Â timestamp; SerializeJson(doc,Serial); XML kÃ¼tÃ¼phanesine gÃ¶re Ã§ok daha basittir. Veri transfer iÃ§in sadece Json document dosyasÄ± ile oluÅŸturulmuÅŸ Ã¶rneÄŸin SerializeJson fonksiyonuna \u0026ldquo;Serial\u0026rdquo; fonksiyonu ile gÃ¶ndermek.\nDiÄŸer genel formatlar.\nSaf binary format:\n  Protocol Buffer\n  Cap\u0026rsquo;n Proto\n  Apache Trift\n  Binary JSONS:\n MessagePack BSON CBOR  Extansions of JSON:\n JSON5 HanSON Amazon Ion  NanoPb HazÄ±rlayan:\nğŸ…´ğŸ…½ğŸ…´ğŸ†‚ ğŸ…°ğŸ…»ğŸ…¿\n","date":"2021-07-22T00:00:00Z","image":"https://techenginer-alp.netlify.app/p/com/com_hufa5a21e3b2bf66612552e05d1232a6a3_166093_120x120_fill_q75_box_smart1.jpg","permalink":"https://techenginer-alp.netlify.app/p/com/","title":"GÃ¶mÃ¼lÃ¼ Sistemlerde HaberleÅŸme"}]